4주차
실제로DeZero의 성능이 중요하다 = 많은 양의 계산을 위해 =성능 개선
사용자의 편의성을 위해 메모리 속도를 개선과 같은 형식을 유저 인터페이스 후 패키지화 하기 위함.
파이썬 메모리의 원리는 필요 없는 객체에 대해 참조가 없기에 자동 삭제 된다.    
out of memory 같은 메모리 부족 문제를 해결하기 위함.
메모리에는 파라미터가 크기에 시간이 많이 걸림.
파이선의 메모리 레퍼런스를 사용하여 객체의 클래스 인스턴스를 만들어서 사용하기에 장시간 동안 참조를 사용하지 않은 경우 
파이썬은 메모리를 제거
가비지 컬랙션 세대별로 쓸모 없는 객체를 삭제하는 방식 총 두가지 있음.
참조 - 카운터  참조 카운트가 0이 되면 회수가 진행됨.
참조가 계속적으로 기입시 참조카운트가증가 
      장시간 사용하지않을시 감소
순환 참조 - 서로 연쇄적으로 참조 되고 있음. 
서로를 참조하기 때문에 삭제되지 않음. 
그래서 가비지 컬렉션을 사용하여, 메모리가 부족해지는 시점에서  파이썬 인터프리터에서 자동 호출되어 해제된다. 
허나 가비지 컬렉션을 사용 시 메모리량이 증가 됨. 
메모리가 증가하면 수행 속도가 느리기 때문에 DeZero를 사용 시 순환 참조로 제작하는 것은 좋지 않다. 
위의 상황을 보안하기 위해 약한 참조가 제작되었고.
객채를 참조하지만 카운트는 증가 되지 않는 기능이다. 
메모리를 절약하는방법 
1. 역전파 사용시에 불필요한 중간 계산메모리를 즉시 삭제하는 방법.
2. 모드를 사용하여 삭제하는 방법- 아예 역전파를 사용하지 않는 방법.
   retain_grad를 사용하여 중간값을 삭제한다.
  with문을 사용하여, 안에서 역전파 비활성화 및 이 블록을 벗어나면 일반화라고 한다.
역전파가 필요없는경우 편의를 위해 no_grad를 사용한다.
Variable 인스턴스에서 할 수 있도록 shape 함수를 사용하여 확장 시킬 수 있다.
   repr 메소를드를 사용하여 객체의 상태를재현하는데 유용한 문자로 반환시켜 준다.
C++의연산자 오버로드와 상당히 유사한 연산자를 Variable에 확장시키는 것이다.
y = a*b 처럼 코딩할 수 있도록 제작.
mul 클래스는 *
class Variable:
....
 Variable.mul_ = mul
 Variable.add_ = add
가 전제로 있어야 한다. 
__mul__(self,other) 여기서 self는 a값 other 는 b값이다.
아이디어란 nd.array 인스턴스를 자동으로 Variable으로 변환하는 것이다.
 mul과 rmul은 틀리다.
사칙연산의 연산자 우선순위를 인스턴스들에대입을 시켜 우선순위 지정.
Function클래스를 사용하여, 연산자들을 새로 추가한다.
음수를 대입하기 위해 forward와 backward를 항상 대입해야한다.
그리고 neg함수를 사용.
뺄셈은 rsub을정의후 인수의 순서를 바꿔  sub를 호출
나눗셈은 backward에 미분을 진행한다.
거듭제곱급도 같다.
